(defclass proof (trace)
  ((name :initarg :name :accessor name)
   (params :initarg :params :accessor params)
   (premises :initarg :premises :accessor premises)))
(defclass axiom-rule (proof) ())
(defclass cut-rule (proof) ())
(defclass weak-rule (proof) ())
(defclass contr-rule (proof) ())
(defclass true-rule (proof) ())
(defclass not-true-rule (proof) ())
(defclass false-rule (proof) ())
(defclass not-false-rule (proof) ())
(defclass and-rule (proof) ())
(defclass not-and-rule (proof) ())
(defclass or-rule (proof) ())
(defclass not-or-rule (proof) ())
(defclass implication-rule (proof) ())
(defclass not-implication-rule (proof) ())
(defclass iff-rule (proof) ())
(defclass not-iff-rule (proof) ())
(defclass if-rule (proof) ())
(defclass not-if-rule (proof) ())
(defclass not-not-rule (proof) ())
(defclass forall-rule (proof) ())
(defclass not-forall-rule (proof) ())
(defclass exists-rule (proof) ())
(defclass not-exists-rule (proof) ())
(defclass refl-rule (proof) ())
(defclass trans-rule (proof) ())
(defclass leibniz-rule (proof) ())
(defclass congruence-rule (proof) ())
(defclass if-then-congruence-rule (proof) ())
(defclass if-else-congruence-rule (proof) ())
(defclass extprop-rule (proof) ())
(defclass extlambda-rule (proof) ())
(defclass extforall-rule (proof) ())
(defclass extexists-rule (proof) ())
(defclass rewrite-rule (proof) ())
(defclass trusted-rule (proof) ())
(defclass tcc-rule (proof) ())
;; the last two never appear in final proofs
(defclass hole-rule (proof) ())
(defclass not-implemented-rule (proof) ())

;; DEBUG

(defun assert-debug (test name elts)
  (unless test
    (format t "~%~a" name)
    ;; (show (cdr (cadr elts)))
    ;; (show (car (cdr (caddr elts))))
    ;; (format t "~%equality: ~a" (tc-eq (cdr (cadr elts)) (car (cdr (caddr elts)))))
    (mapc #'(lambda (elt)
	      (format t "~%~a: ~a" (car elt) (cdr elt)))
	  elts)
    (format t "~%")
    (assert (and 'assert-debug nil))))

(defun warn-debug (test name elts)
  (unless test
    (format t "~%~a" name)
    (mapc #'(lambda (elt)
	      (format t "~%~a: ~a" (car elt) (cdr elt)))
	  elts)
    (format t "~%")))

(defun throw-debug (test tag elts)
  (unless test
    (format t "~%~a" tag)
    (mapc #'(lambda (elt)
	      (format t "~%~a: ~a" (car elt) (cdr elt)))
	  elts)
    (format t "~%")
    (throw tag 'debug-const)))

;; it is a macro to be able to catch an error during the execution of prog
(defmacro catch-debug (tag prog name elts)
  (let ((result (gentemp)))
    `(let ((,result
	    (catch ,tag (multiple-value-list ,prog))))
       (assert-debug (not (eq ,result 'debug-const))
		     ,name ,elts)
       (values-list ,result))))

(defmacro catch-throw-debug (tag1 prog tag2 elts)
  (let ((result (gentemp)))
    `(let ((,result
	    (catch ,tag1 (multiple-value-list ,prog))))
       (throw-debug (not (eq ,result 'debug-const))
		    ,tag2 ,elts)
       (values-list ,result))))

(defmacro catch-all-debug (body)
  (let ((val (gentemp)))
  `(handler-case
    ,body
    (condition (,val)
	       (declare (ignore ,val))
	       (format t "~%an error occurred")
	       (assert (and 'catch nil))))))

(defun make-proof (rule-name params premises)
  (throw-debug (proof-list? premises)
	       'make-proof 
	       (list (cons "rule-name" rule-name)
	             (cons "params" params)
	             (cons "premises" premises))
	       )
  (throw-debug (proof-coherent-params rule-name params)
	       'make-proof
	       nil
	       ;; (list (cons "rule-name" rule-name)
	       ;;       (cons "params" params)
	       ;;       (cons "premises" premises))
	       )
  (throw-debug (proof-coherent-nb-premises rule-name (length premises))
	       'make-proof
	       (list (cons "rule-name" rule-name)
	             (cons "params" params)
	             (cons "premises" premises)))
  (make-instance rule-name
		 :name rule-name
		 :params params
		 :premises premises))

;; COMPUTE AND CHECK TYPE OF PROOFS

(defvar *well-typed-trace* nil)

(defmethod well-typed-trace ((proof proof) antecedents (consequent sequent))
  (assert-debug (sequent-list? antecedents)
		"well-typed-trace" (list (cons "subgoals" antecedents)))
  (let ((result
	 (catch 'compute-antecedents-premises-error
	   (well-typed-trace* proof antecedents consequent))))
    ;; (warn-debug (null (cdr result))
    ;; 		"well-typed-trace, proofs.lisp"
    ;; 		(list (cons "proof" proof)
    ;; 		      (cons "antecedents" antecedents)
    ;; 		      (cons "consequent" consequent)
    ;; 		      (cons "cdr" (cdr result))))
    (and (not (eq result 'debug-const)) (null (cdr result)) (car result))))

(defmethod well-typed-trace* ((proof hole-rule) antecedents (consequent sequent))
  (assert (sequent-list? antecedents))
  (if (not (consp antecedents))
      (progn
	(setq *well-typed-trace* nil)
	(cons nil nil))
    (cons (compute-sequent-eq consequent (car antecedents))
	  (cdr antecedents))))

;; (defmethod well-typed-trace* :around (proof antecedents (consequent sequent))
;;   (format t "~%test~a" (name proof))
;;   (format t "~%test")
;;   (call-next-method))

(defmethod well-typed-trace* ((proof not-implemented-rule) antecedents (consequent sequent))
  (assert (sequent-list? antecedents))
  (cons t (remove-antecedents proof antecedents)))

;; (defvar *mynewtest* nil)

(defmethod well-typed-trace* ((proof rewrite-rule) antecedents (consequent sequent))
  (declare (ignore antecedents))
  ;; (show (cadr (params proof)))
  ;; (show (declaration (car (resolutions (operator (caddr (params proof)))))))
  ;; (assert nil)
  (unless (tc-eq (compute-normalize (cadr (params proof)))
  		 (compute-normalize (caddr (params proof))))
    ;; (let ((*mynewtest* t))
    ;;   (show (compute-normalize (caddr (params proof)))))
    (show (compute-normalize (cadr (params proof))))
    (show (compute-normalize (caddr (params proof))))
    (assert (and 'problem-normalize nil)))
  (call-next-method))

(defmethod well-typed-trace* ((proof proof) antecedents (consequent sequent))
  (assert (sequent-list? antecedents))
  (let* ((*well-typed-trace* t)
	 (cons-antecedents-premises
	  (compute-antecedents-premises proof consequent));;fails in case of ill typed lowest rule
	 (cons-checked-remaining
	  (reduce
	   #'(lambda (cons-checked-remaining cons-antecedent-premise)
	       (let* ((aux (well-typed-trace* (cdr cons-antecedent-premise)
					      (cdr cons-checked-remaining)
					      (car cons-antecedent-premise))))
		 (cons (cons (car aux) (car cons-checked-remaining)) ;; done
		       (cdr aux)))) ;; remaining
	   (cons (cons nil antecedents) cons-antecedents-premises)))
	 (remaining (cdr cons-checked-remaining))
	 (checked (car cons-checked-remaining)))
    (cons (and *well-typed-trace* (every #'(lambda (x) x) checked))
	  remaining)))


(defmethod remove-antecedents ((proof hole-rule) antecedents)
  (assert (sequent-list? antecedents))
  (assert (consp antecedents))
  (cdr antecedents))

(defmethod remove-antecedents ((proof proof) antecedents)
  (assert (sequent-list? antecedents))
  (reduce
   #'(lambda (remaining premise)
       (remove-antecedents premise remaining)) ;; remaining
   (cons antecedents (premises proof))))

(defmethod compute-antecedents-premises ((proof proof) (sequent sequent))
  ;; (format t "sequent : ~%~a~%" sequent)
  ;; (format t "proof : ~%~a~%" proof)
  (let* ((sforms (append (s-forms sequent) (hidden-s-forms sequent) nil))
	 (forms (mapcar #'formula sforms))
	 (context
	  (reduce #'(lambda (forms conclusion)
		      (when (not (find conclusion forms :test #'compute-form-eq))
			(setq *well-typed-trace* nil)
			;; (show (car (resolutions
			;; 	    (car (arguments
			;; 		  (expression (expression (expression conclusion))))))))
			;; (show (car (resolutions
			;; 	    (car (arguments
			;; 		  (expression (expression (expression (car forms)))))))))
			;; (format t "~%~a"
			;; 	(compute-form-eq
			;; 	 (car (resolutions
			;; 	       (car (arguments (expression
			;; 				(expression (expression conclusion)))))))
			;; 	 (car (resolutions
			;; 	       (car (arguments (expression
			;; 				(expression (expression (car forms))))))))))
			;; (format t "~%~a" (compute-form-eq conclusion (car forms)))
			;; (assert nil)
			)
		      (throw-debug (find conclusion forms :test #'compute-form-eq)
		      		    'compute-antecedents-premises-error
		      		    (list (cons "proof" proof)
		      			  (cons "conclusion" conclusion)
		      			  (cons "forms" forms)))
		      (remove conclusion forms :test #'compute-form-eq :count 1))
		  (cons forms (rule-conclusions proof)))))
    (mapcar #'(lambda (hypotheses premise)
		(let* ((new-forms (append context hypotheses))
		       (new-sforms (mapcar #'compute-s-form new-forms)))
		  (cons (lcopy sequent 's-forms new-sforms 'hidden-s-forms nil)
			premise)))
	    (rule-hypotheses proof) (premises proof))))

(defmethod antecedents ((proof proof) (sequent sequent))
  (mapcar #'car (compute-antecedents-premises proof sequent)))

(defun replace-sequent (sequent old new)
  (let* ((sforms (append (s-forms sequent) (hidden-s-forms sequent) nil))
	 (forms (mapcar #'formula sforms))
	 (context
	  (progn (throw-debug (find old forms :test #'compute-form-eq)
			      'compute-antecedents-premises-error
			      (list (cons "conclusion" old)
				    (cons "forms" forms)))
		 (remove old forms :test #'compute-form-eq :count 1)))
	 (new-forms (cons new context))
	 (new-sforms (mapcar #'compute-s-form new-forms)))
    (lcopy sequent 's-forms new-sforms 'hidden-s-forms nil)))

(defmethod compute-hole-sequents ((proof hole-rule) (sequent sequent))
  (list sequent))

(defmethod compute-hole-sequents ((proof not-implemented-rule) (sequent sequent))
  (assert (and 'notimplementednotallowed nil)))

(defmethod compute-hole-sequents ((proof proof) (sequent sequent))
  (let* ((cons-antecedents-premises
	  (compute-antecedents-premises proof sequent))
	 (results (mapcar #'(lambda (cons-antecedent-premise)
			      (compute-hole-sequents (cdr cons-antecedent-premise)
						     (car cons-antecedent-premise)))
			  cons-antecedents-premises))
	 ;; (result (find-if-not #'null results))
	 )
    ;; (assert (and 'noholefound result))
    (apply #'append results)))

(defun caddddr (x)
  (car (cddddr x)))

;; HYPOTHESES AND CONCLUSIONS

(defmethod rule-hypotheses ((proof hole-rule))
  nil)
(defmethod rule-hypotheses ((proof not-implemented-rule))
  (assert (and 'not-implem nil)))
(defmethod rule-hypotheses ((proof true-rule))
  nil)
(defmethod rule-hypotheses ((proof not-false-rule))
  nil)
(defmethod rule-hypotheses ((proof not-not-rule))
  (list
   (list (car (params proof)))))
(defmethod rule-hypotheses ((proof and-rule))
  (list
   (list (car (params proof)))
   (list (cadr (params proof)))))
(defmethod rule-hypotheses ((proof weak-rule))
  (list
   nil))
(defmethod rule-hypotheses ((proof axiom-rule))
  nil)
(defmethod rule-hypotheses ((proof implication-rule))
  (list
   (list (compute-negation (car (params proof))) (cadr (params proof)))))
(defmethod rule-hypotheses ((proof or-rule))
  (list
   (list (car (params proof)) (cadr (params proof)))))
(defmethod rule-hypotheses ((proof trans-rule))
  (list
   (list (compute-equation (car (params proof)) (cadr (params proof))))
   (list (compute-equation (cadr (params proof)) (caddr (params proof))))))
(defmethod rule-hypotheses ((proof not-and-rule))
  (list
   (list (compute-negation (car (params proof)))
	 (compute-negation (cadr (params proof))))))
(defmethod rule-hypotheses ((proof not-or-rule))
  (list
   (list (compute-negation (car (params proof))))
   (list (compute-negation (cadr (params proof))))))
(defmethod rule-hypotheses ((proof contr-rule))
  (list
   (list (car (params proof))
	 (car (params proof)))))
(defmethod rule-hypotheses ((proof not-forall-rule))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-negation (compute-substit expr alist))))))
(defmethod rule-hypotheses ((proof not-implication-rule))
  (list
   (list (compute-negation (cadr (params proof))))
   (list (car (params proof)))))
(defmethod rule-hypotheses ((proof not-exists-rule))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-negation (compute-substit expr alist))))))
(defmethod rule-hypotheses ((proof false-rule))
  (list
   (list *false*)))
(defmethod rule-hypotheses ((proof not-true-rule))
  (list
   (list (compute-negation *true*))))
(defmethod rule-hypotheses ((proof exists-rule))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-substit expr alist)))))
(defmethod rule-hypotheses ((proof forall-rule))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    ;; (when (and (forall-expr? expr)
    ;; 	       (exists-expr? (expression expr))
    ;; 	       (forall-expr? (expression (expression expr))))
    ;;   (format t "~%expr ~a" expr)
    ;;   (format t "~%alist ~a" alist)
    ;;   (show (type (car (bindings expr))))
    ;;   (format t "~%result ~a" (compute-substit (type (car (bindings expr))) alist))
    ;;   (assert nil))
    (list
     (list (compute-substit expr alist)))))
(defmethod rule-hypotheses ((proof cut-rule))
  (list
   (list (car (params proof)))
   (list (compute-negation (car (params proof))))))
(defmethod rule-hypotheses ((proof refl-rule))
  nil)
(defmethod rule-hypotheses ((proof leibniz-rule))
  (let ((expr (expr (car (params proof))))
	(var (car (binds (car (params proof)))))
	(a (cadr (params proof)))
	(b (caddr (params proof))))
    (list
     (list (compute-instantiate expr (list (cons var a))))
     (list (compute-equation a b)))))
(defmethod rule-hypotheses ((proof extprop-rule))
  (list
   (list (compute-iff (car (params proof)) (cadr (params proof))))))
(defmethod rule-hypotheses ((proof extlambda-rule))
  (list
   (list (compute-equation (cadr (params proof)) (caddr (params proof))))))
(defmethod rule-hypotheses ((proof extforall-rule))
  (list
   (list (compute-equation (cadr (params proof)) (caddr (params proof))))))
(defmethod rule-hypotheses ((proof extexists-rule))
  (list
   (list (compute-equation (cadr (params proof)) (caddr (params proof))))))
(defmethod rule-hypotheses ((proof congruence-rule))
  (list
   (list (compute-equation (caddr (params proof)) (cadddr (params proof))))))
(defmethod rule-hypotheses ((proof if-then-congruence-rule))
  (list
   (list (compute-negation (cadr (params proof)))
	 (compute-equation (caddr (params proof)) (cadddr (params proof))))))
(defmethod rule-hypotheses ((proof if-else-congruence-rule))
  (list
   (list (cadr (params proof))
	 (compute-equation (cadddr (params proof)) (caddddr (params proof))))))
(defmethod rule-hypotheses ((proof iff-rule))
  (list
   (list (compute-implication (car (params proof)) (cadr (params proof))))
   (list (compute-implication (cadr (params proof)) (car (params proof))))))
(defmethod rule-hypotheses ((proof not-iff-rule))
  (list
   (list (compute-negation (compute-implication (car (params proof)) (cadr (params proof))))
	 (compute-negation (compute-implication (cadr (params proof)) (car (params proof)))))))
(defmethod rule-hypotheses ((proof if-rule))
  (list
   (list (compute-implication (car (params proof))
			      (cadr (params proof))))
   (list (compute-implication (compute-negation (car (params proof)))
			      (caddr (params proof))))))
(defmethod rule-hypotheses ((proof not-if-rule))
  (list
   (list (compute-negation (compute-conjunction (car (params proof))
						(cadr (params proof)))))
   (list (compute-negation (compute-conjunction (compute-negation (car (params proof)))
						(caddr (params proof)))))))
(defmethod rule-hypotheses ((proof rewrite-rule))
  (let ((expr (expression (car (params proof))))
	(var (car (bindings (car (params proof)))))
	(a (cadr (params proof))))
    (list
     (list (compute-instantiate expr (list (cons var a)))))))
(defmethod rule-hypotheses ((proof trusted-rule))
  (cadr (params proof)))
(defmethod rule-hypotheses ((proof tcc-rule))
  (cons
   (cadr (params proof))
   (car (params proof))))


(defmethod rule-conclusions ((proof hole-rule))
  nil)
(defmethod rule-conclusions ((proof not-implemented-rule))
  (assert (and 'not-implem2 nil)))
(defmethod rule-conclusions ((proof true-rule))
  (list *true*))
(defmethod rule-conclusions ((proof not-false-rule))
  (list (compute-negation *false*)))
(defmethod rule-conclusions ((proof not-not-rule))
  (list (compute-negation (compute-negation (car (params proof))))))
(defmethod rule-conclusions ((proof and-rule))
  (list (compute-conjunction (car (params proof)) (cadr (params proof)))))
(defmethod rule-conclusions ((proof weak-rule))
  (list (car (params proof))))  
(defmethod rule-conclusions ((proof axiom-rule))
  (list (car (params proof)) (compute-negation (car (params proof)))))
(defmethod rule-conclusions ((proof implication-rule))
  (list (compute-implication (car (params proof)) (cadr (params proof)))))
(defmethod rule-conclusions ((proof or-rule))
  (list (compute-disjunction (car (params proof)) (cadr (params proof)))))
(defmethod rule-conclusions ((proof trans-rule))
  (list (compute-equation (car (params proof)) (caddr (params proof)))))
(defmethod rule-conclusions ((proof not-and-rule))
  (list (compute-negation (compute-conjunction (car (params proof)) (cadr (params proof))))))
(defmethod rule-conclusions ((proof not-or-rule))
  (list (compute-negation (compute-disjunction (car (params proof)) (cadr (params proof))))))
(defmethod rule-conclusions ((proof contr-rule))
  (list (car (params proof))))
(defmethod rule-conclusions ((proof not-forall-rule))
  (list (compute-negation
	 (compute-forall (mapcar #'car (cadr (params proof))) (car (params proof))))))
(defmethod rule-conclusions ((proof not-implication-rule))
  (list (compute-negation (compute-implication (car (params proof)) (cadr (params proof))))))
(defmethod rule-conclusions ((proof not-exists-rule))
  (list (compute-negation
	 (compute-exists (mapcar #'car (cadr (params proof))) (car (params proof))))))
(defmethod rule-conclusions ((proof false-rule))
  nil)
(defmethod rule-conclusions ((proof not-true-rule))
  nil)
(defmethod rule-conclusions ((proof exists-rule))
  (list (compute-exists (mapcar #'car (cadr (params proof))) (car (params proof)))))
(defmethod rule-conclusions ((proof forall-rule))
  (list (compute-forall (mapcar #'car (cadr (params proof))) (car (params proof)))))
(defmethod rule-conclusions ((proof cut-rule))
  nil)
(defmethod rule-conclusions ((proof refl-rule))
  (list (compute-equation (car (params proof)) (car (params proof)))))
(defmethod rule-conclusions ((proof leibniz-rule))
  (let ((expr (expr (car (params proof))))
	(var (car (binds (car (params proof)))))
	(b (caddr (params proof))))
    (list (compute-instantiate expr (list (cons var b))))))
(defmethod rule-conclusions ((proof extprop-rule))
  (list (compute-equation (car (params proof)) (cadr (params proof)))))
(defmethod rule-conclusions ((proof extlambda-rule))
  (list (compute-equation (compute-lambda (car (params proof)) (cadr (params proof)))
			  (compute-lambda (car (params proof)) (caddr (params proof))))))
(defmethod rule-conclusions ((proof extforall-rule))
  (list (compute-equation (compute-forall (car (params proof)) (cadr (params proof)))
			  (compute-forall (car (params proof)) (caddr (params proof))))))
(defmethod rule-conclusions ((proof extexists-rule))
  (list (compute-equation (compute-exists (car (params proof)) (cadr (params proof)))
			  (compute-exists (car (params proof)) (caddr (params proof))))))
(defmethod rule-conclusions ((proof congruence-rule))
  (list (compute-equation (compute-substit (car (params proof))
					   (list (cons (cadr (params proof))
						       (caddr (params proof)))))
			  (compute-substit (car (params proof))
					   (list (cons (cadr (params proof))
						       (cadddr (params proof))))))))
(defmethod rule-conclusions ((proof if-then-congruence-rule))
  (list (compute-equation (compute-application
			   (car (params proof))
			   (compute-tuple
			    (list (cadr (params proof))
				  (caddr (params proof))
				  (caddddr (params proof)))))
			  (compute-application
			   (car (params proof))
			   (compute-tuple
			    (list (cadr (params proof))
				  (cadddr (params proof))
				  (caddddr (params proof))))))))
(defmethod rule-conclusions ((proof if-else-congruence-rule))
  (list (compute-equation (compute-application
			   (car (params proof))
			   (compute-tuple
			    (list (cadr (params proof))
				  (caddr (params proof))
				  (cadddr (params proof)))))
			  (compute-application
			   (car (params proof))
			   (compute-tuple
			    (list (cadr (params proof))
				  (caddr (params proof))
				  (caddddr (params proof))))))))
(defmethod rule-conclusions ((proof iff-rule))
  (list (compute-iff (car (params proof)) (cadr (params proof)))))
(defmethod rule-conclusions ((proof not-iff-rule))
  (list (compute-negation (compute-iff (car (params proof)) (cadr (params proof))))))
(defmethod rule-conclusions ((proof if-rule))
  (list (compute-boolean-if (car (params proof)) (cadr (params proof)) (caddr (params proof)))))
(defmethod rule-conclusions ((proof not-if-rule))
  (list (compute-negation
	 (compute-boolean-if (car (params proof)) (cadr (params proof)) (caddr (params proof))))))
(defmethod rule-conclusions ((proof rewrite-rule))
  (let ((expr (expression (car (params proof))))
	(var (car (bindings (car (params proof)))))
	(b (caddr (params proof))))
    (list (compute-instantiate expr (list (cons var b))))))
(defmethod rule-conclusions ((proof trusted-rule))
  (caddr (params proof)))
(defmethod rule-conclusions ((proof tcc-rule))
  (cadr (params proof)))

;; SUBSTITUTION

(defmethod instantiate-vars-proof ((proof hole-rule) alist)
  (declare (ignore alist))
  (make-proof 'hole-rule nil nil))
(defmethod instantiate-vars-proof ((proof not-implemented-rule) alist)
  (declare (ignore alist))
  (assert (and '2 nil))
  )
(defmethod instantiate-vars-proof ((proof true-rule) alist)
  (declare (ignore alist))
  (assert (and '3 nil))
  nil)
(defmethod instantiate-vars-proof ((proof not-false-rule) alist)
  (declare (ignore alist))
  (assert (and '4 nil))
  nil)
(defmethod instantiate-vars-proof ((proof not-not-rule) alist)
  (declare (ignore alist))
  (assert (and '5 nil))
  (list
   (list (car (params proof)))))
(defmethod instantiate-vars-proof ((proof and-rule) alist)
  (declare (ignore alist))
  (assert (and '6 nil))
  (list
   (list (car (params proof)))
   (list (cadr (params proof)))))
(defmethod instantiate-vars-proof ((proof weak-rule) alist)
  (declare (ignore alist))
  (assert (and '7 nil))
  (list
   nil))
(defmethod instantiate-vars-proof ((proof axiom-rule) alist)
  (declare (ignore alist))
  (assert (and '8 nil))
  nil)
(defmethod instantiate-vars-proof ((proof implication-rule) alist)
  (declare (ignore alist))
  (assert (and '9 nil))
  (list
   (list (compute-negation (car (params proof))) (cadr (params proof)))))
(defmethod instantiate-vars-proof ((proof or-rule) alist)
  (declare (ignore alist))
  (assert (and '10 nil))
  (list
   (list (car (params proof)) (cadr (params proof)))))
(defmethod instantiate-vars-proof ((proof trans-rule) alist)
  (declare (ignore alist))
  (assert (and '10bis nil))
  (list
   (list (car (params proof)) (cadr (params proof)))))
(defmethod instantiate-vars-proof ((proof not-and-rule) alist)
  (declare (ignore alist))
  (assert (and '11 nil))
  (list
   (list (compute-negation (car (params proof)))
	 (compute-negation (cadr (params proof))))))
(defmethod instantiate-vars-proof ((proof not-or-rule) alist)
  (declare (ignore alist))
  (assert (and '12 nil))
  (list
   (list (compute-negation (car (params proof))))
   (list (compute-negation (cadr (params proof))))))
(defmethod instantiate-vars-proof ((proof contr-rule) alist)
  (declare (ignore alist))
  (assert (and '13 nil))
  (list
   (list (car (params proof))
	 (car (params proof)))))
(defmethod instantiate-vars-proof ((proof not-forall-rule) alist)
  (declare (ignore alist))
  (assert (and '14 nil))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-negation (compute-substit expr alist))))))
(defmethod instantiate-vars-proof ((proof not-implication-rule) alist)
  (declare (ignore alist))
  (assert (and '15 nil))
  (list
   (list (compute-negation (cadr (params proof))))
   (list (car (params proof)))))
(defmethod instantiate-vars-proof ((proof not-exists-rule) alist)
  (declare (ignore alist))
  (assert (and '16 nil))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-negation (compute-substit expr alist))))))
(defmethod instantiate-vars-proof ((proof false-rule) alist)
  (declare (ignore alist))
  (assert (and '17 nil))
  (list
   (list *false*)))
(defmethod instantiate-vars-proof ((proof not-true-rule) alist)
  (declare (ignore alist))
  (assert (and '18 nil))
  (list
   (list (compute-negation *true*))))
(defmethod instantiate-vars-proof ((proof exists-rule) alist)
  (declare (ignore alist))
  (assert (and '19 nil))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-substit expr alist)))))
(defmethod instantiate-vars-proof ((proof forall-rule) alist)
  (declare (ignore alist))
  (assert (and '20 nil))
  (let ((expr (car (params proof)))
	(alist (cadr (params proof))))
    (list
     (list (compute-substit expr alist)))))
(defmethod instantiate-vars-proof ((proof cut-rule) alist)
  (declare (ignore alist))
  (assert (and '21 nil))
  (list
   (list (car (params proof)))
   (list (compute-negation (car (params proof))))))
(defmethod instantiate-vars-proof ((proof refl-rule) alist)
  (declare (ignore alist))
  (assert (and '22 nil))
  nil)
(defmethod instantiate-vars-proof ((proof leibniz-rule) alist)
  (declare (ignore alist))
  (assert (and '23 nil))
  (let ((expr (expr (car (params proof))))
	(var (car (binds (car (params proof)))))
	(a (cadr (params proof)))
	(b (caddr (params proof))))
    (list
     (list (compute-instantiate expr (list (cons var a))))
     (list (compute-equation a b)))))
(defmethod instantiate-vars-proof ((proof extprop-rule) alist)
  (declare (ignore alist))
  (assert (and '24 nil))
  (list
   (list (compute-iff (car (params proof)) (cadr (params proof))))))
(defmethod instantiate-vars-proof ((proof extlambda-rule) alist)
  (make-proof 'extlambda-rule
	      (list (car (params proof))
		    (compute-instantiate (cadr (params proof)) alist)
		    (compute-instantiate (caddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof extforall-rule) alist)
  (make-proof 'extforall-rule
	      (list (car (params proof))
		    (compute-instantiate (cadr (params proof)) alist)
		    (compute-instantiate (caddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof extexists-rule) alist)
  (make-proof 'extexists-rule
	      (list (car (params proof))
		    (compute-instantiate (cadr (params proof)) alist)
		    (compute-instantiate (caddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof congruence-rule) alist)
  (make-proof 'congruence-rule
	      (list (compute-instantiate (car (params proof)) alist)
		    (cadr (params proof))
		    (compute-instantiate (caddr (params proof)) alist)
		    (compute-instantiate (cadddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof if-then-congruence-rule) alist)
  (make-proof 'if-then-congruence-rule
	      (list (compute-instantiate (car (params proof)) alist)
		    (compute-instantiate (cadr (params proof)) alist)
		    (compute-instantiate (caddr (params proof)) alist)
		    (compute-instantiate (cadddr (params proof)) alist)
		    (compute-instantiate (caddddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof if-else-congruence-rule) alist)
  (make-proof 'if-else-congruence-rule
	      (list (compute-instantiate (car (params proof)) alist)
		    (compute-instantiate (cadr (params proof)) alist)
		    (compute-instantiate (caddr (params proof)) alist)
		    (compute-instantiate (cadddr (params proof)) alist)
		    (compute-instantiate (caddddr (params proof)) alist))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof iff-rule) alist)
  (declare (ignore alist))
  (assert (and '26 nil))
  (list
   (list (compute-implication (car (params proof)) (cadr (params proof))))
   (list (compute-implication (cadr (params proof)) (car (params proof))))))
(defmethod instantiate-vars-proof ((proof not-iff-rule) alist)
  (declare (ignore alist))
  (assert (and '27 nil))
  (list
   (list (compute-negation (compute-implication (car (params proof)) (cadr (params proof))))
	 (compute-negation (compute-implication (cadr (params proof)) (car (params proof)))))))
(defmethod instantiate-vars-proof ((proof if-rule) alist)
  (declare (ignore alist))
  (assert (and '28 nil))
  (list
   (list (compute-implication (car (params proof))
			      (cadr (params proof))))
   (list (compute-implication (compute-negation (car (params proof)))
			      (caddr (params proof))))))
(defmethod instantiate-vars-proof ((proof not-if-rule) alist)
  (declare (ignore alist))
  (assert (and '29 nil))
  (list
   (list (compute-negation (compute-conjunction (car (params proof))
						(cadr (params proof)))))
   (list (compute-negation (compute-conjunction (compute-negation (car (params proof)))
						(caddr (params proof)))))))
(defmethod instantiate-vars-proof ((proof rewrite-rule) alist)
  (declare (ignore alist))
  (assert (and '30 nil))
  (let ((expr (expression (car (params proof))))
	(var (car (bindings (car (params proof)))))
	(a (cadr (params proof))))
    (list
     (list (compute-instantiate expr (list (cons var a)))))))
(defmethod instantiate-vars-proof ((proof trusted-rule) alist)
  (make-proof 'trusted-rule
	      (list (car (params proof))
		    (mapcar #'(lambda (exs)
				(mapcar #'(lambda (ex)
					    (compute-instantiate ex alist))
					exs))
			    (cadr (params proof)))
		    (mapcar #'(lambda (ex)
				(compute-instantiate ex alist))
			    (caddr (params proof))))
	      (mapcar #'(lambda (proof)
			  (instantiate-vars-proof proof alist))
		      (premises proof))))
(defmethod instantiate-vars-proof ((proof tcc-rule) alist)
  (declare (ignore alist))
  (assert (and '34 nil))
  (cons
   (cadr (params proof))
   (car (params proof))))

;; PRINT NAMES

(defmethod pp-rule-name ((proof hole-rule))
  (write "RHole"))
(defmethod pp-rule-name ((proof not-implemented-rule))
  (write "RNotImplemented"))
(defmethod pp-rule-name ((proof true-rule))
  (write "RTrue"))
(defmethod pp-rule-name ((proof not-false-rule))
  (write "RNotFalse"))
(defmethod pp-rule-name ((proof not-not-rule))
  (write "RNotNot"))
(defmethod pp-rule-name ((proof and-rule))
  (write "RAnd"))
(defmethod pp-rule-name ((proof weak-rule))
  (write "RWeak"))
(defmethod pp-rule-name ((proof axiom-rule))
  (write "RAxiom"))
(defmethod pp-rule-name ((proof implication-rule))
  (write "Rimply"))
(defmethod pp-rule-name ((proof or-rule))
  (write "ROr"))
(defmethod pp-rule-name ((proof trans-rule))
  (write "RTrans"))
(defmethod pp-rule-name ((proof not-and-rule))
  (write "RNotAnd"))
(defmethod pp-rule-name ((proof not-or-rule))
  (write "RNotOr"))
(defmethod pp-rule-name ((proof contr-rule))
  (write "RContr"))
(defmethod pp-rule-name ((proof not-forall-rule))
  (write "RNotForall"))
(defmethod pp-rule-name ((proof not-implication-rule))
  (write "RNotImplication"))
(defmethod pp-rule-name ((proof not-exists-rule))
  (write "RNotExists"))
(defmethod pp-rule-name ((proof false-rule))
  (write "RFalse"))
(defmethod pp-rule-name ((proof not-true-rule))
  (write "RNotTrue"))
(defmethod pp-rule-name ((proof exists-rule))
  (write "RExists"))
(defmethod pp-rule-name ((proof forall-rule))
  (write "RForall"))
(defmethod pp-rule-name ((proof cut-rule))
  (write "RCut"))
(defmethod pp-rule-name ((proof refl-rule))
  (write "RRefl"))
(defmethod pp-rule-name ((proof leibniz-rule))
  (write "RLeibniz"))
(defmethod pp-rule-name ((proof extprop-rule))
  (write "RExtProp"))
(defmethod pp-rule-name ((proof extlambda-rule))
  (write "RExtLambda"))
(defmethod pp-rule-name ((proof extforall-rule))
  (write "RExtForall"))
(defmethod pp-rule-name ((proof extexists-rule))
  (write "RExtExists"))
(defmethod pp-rule-name ((proof congruence-rule))
  (write "RCongruence"))
(defmethod pp-rule-name ((proof if-then-congruence-rule))
  (write "RIfThenCongruence"))
(defmethod pp-rule-name ((proof if-else-congruence-rule))
  (write "RIfElseCongruence"))
(defmethod pp-rule-name ((proof iff-rule))
  (write "RIff"))
(defmethod pp-rule-name ((proof not-iff-rule))
  (write "RNotIff"))
(defmethod pp-rule-name ((proof if-rule))
  (write "RIf"))
(defmethod pp-rule-name ((proof not-if-rule))
  (write "RNotIf"))
(defmethod pp-rule-name ((proof rewrite-rule))
  (write "RRewrite"))
(defmethod pp-rule-name ((proof trusted-rule))
  (write "RTrusted"))
(defmethod pp-rule-name ((proof tcc-rule))
  (write "RTcc"))

;; PRINT PARAMS

(defun pp-param-list (list)
  (if (null list)
      (pprint-logical-block
       (nil nil)
       (write-char #\()
       (write-char #\)))
    (pprint-logical-block
     (nil list)
     (loop (let ((elt (pprint-pop)))
	     (if (listp elt)
		 (progn
		   (write-char #\()
		   (pp-param-list elt)
		   (write-char #\)))
	       (pp* elt))
	     (pprint-exit-if-list-exhausted)
	     (write-char #\,)
	     (write-char #\space)
	     (pprint-newline :linear))))))

(defmethod pp-rule-params ((proof proof))
  (pp-param-list (params proof)))

;; PRINT PREMISES

(defmethod pp-rule-premises ((proof proof))
  (pprint-logical-block
   (nil (premises proof))
   (loop (pp* (pprint-pop))
	 (pprint-exit-if-list-exhausted)
	 (write-char #\,)
	 (write-char #\space)
	 (pprint-newline :linear))))

;; PRINT PROOFS

(defmethod print-object ((proof proof) stream)
  (let ((*standard-output* stream))
    (pp* proof)))

(defmethod pp* ((proof proof))
  (pprint-logical-block
   (nil nil)
   (pp-rule-name proof)
   (write "(")
   (pprint-indent :block 2)
   (pprint-newline :linear)
   (pp-rule-params proof)
   (when (premises proof)
     (write-char #\;)
     (write-char #\space)
     (pprint-newline :linear)
     (pp-rule-premises proof))
   (write ")")))

(defmethod pp* (expr) ;;string case
  (write expr))


(defmethod pp* ((ctx expr-ctx))
  (pp* (compute-lambda (binds ctx) (expr ctx))))


;; TESTS

(defun proof-coherent-params (rule-name params)
  (or ;;(and (format t "~%test ~a" rule-name) nil)
      (and (eq rule-name 'hole-rule)
	   (null params))
      (and (eq rule-name 'not-implemented-rule)
	   (equal (list-length params) 1))
      (and (eq rule-name 'true-rule)
	   (null params))
      (and (eq rule-name 'not-false-rule)
	   (null params))
      (and (eq rule-name 'not-not-rule)
	   (and (equal (list-length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'and-rule)
	   (and (equal (length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'weak-rule)
	   (and (equal (length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'axiom-rule)
	   (and (equal (list-length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'implication-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'or-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'trans-rule)
	   (and (equal (list-length params) 3)
		(expr? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'not-and-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'not-or-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'contr-rule)
	   (and (equal (list-length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'not-forall-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(subst-list? (cadr params))))
      (and (eq rule-name 'not-implication-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'not-exists-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(subst-list? (cadr params))))
      (and (eq rule-name 'false-rule)
	   (equal (list-length params) 0))
      (and (eq rule-name 'not-true-rule)
	   (equal (list-length params) 0))
      (and (eq rule-name 'exists-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(subst-list? (cadr params))))
      (and (eq rule-name 'forall-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(subst-list? (cadr params))))
      (and (eq rule-name 'cut-rule)
	   (and (equal (list-length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'refl-rule)
	   (and (equal (list-length params) 1)
		(expr? (car params))))
      (and (eq rule-name 'leibniz-rule)
	   (and (equal (list-length params) 3)
		(expr-ctx? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'extprop-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'extlambda-rule)
	   (and (equal (list-length params) 3)
		(listp (car params))
		(every #'binding? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'extforall-rule)
	   (and (equal (list-length params) 3)
		(listp (car params))
		(every #'binding? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'extexists-rule)
	   (and (equal (list-length params) 3)
		(listp (car params))
		(every #'binding? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'congruence-rule)
	   (and (equal (list-length params) 4)
		(expr? (car params))
		(binding? (cadr params))
		(expr? (caddr params))
		(expr? (cadddr params))))
      (and (eq rule-name 'if-then-congruence-rule)
	   (and (equal (list-length params) 5)
		(every #'expr? params)))
      (and (eq rule-name 'if-else-congruence-rule)
	   (and (equal (list-length params) 5)
		(every #'expr? params)))
      (and (eq rule-name 'iff-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'not-iff-rule)
	   (and (equal (list-length params) 2)
		(expr? (car params))
		(expr? (cadr params))))
      (and (eq rule-name 'if-rule)
	   (and (equal (list-length params) 3)
		(expr? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'not-if-rule)
	   (and (equal (list-length params) 3)
		(expr? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'rewrite-rule)
	   (and (equal (list-length params) 3)
		(expr? (car params))
		(expr? (cadr params))
		(expr? (caddr params))))
      (and (eq rule-name 'trusted-rule)
	   (and (equal (list-length params) 3)
		(expr-list-list? (cadr params))
		(expr-list? (caddr params))))
      (and (eq rule-name 'tcc-rule)
	   (and (equal (list-length params) 2)
		(expr-list-list? (car params))
		(expr-list? (cadr params))))
      ))

(defun proof-coherent-nb-premises (rule-name nb-premises)
  (or (and (eq rule-name 'hole-rule)
	   (equal nb-premises 0))
      (eq rule-name 'not-implemented-rule)
      (and (eq rule-name 'true-rule)
	   (equal nb-premises 0))
      (and (eq rule-name 'not-false-rule)
	   (equal nb-premises 0))	   
      (and (eq rule-name 'not-not-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'and-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'weak-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'axiom-rule)
	   (equal nb-premises 0))
      (and (eq rule-name 'implication-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'or-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'trans-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'not-and-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'not-or-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'contr-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'not-forall-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'not-implication-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'not-exists-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'false-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'not-true-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'exists-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'forall-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'cut-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'refl-rule)
	   (equal nb-premises 0))
      (and (eq rule-name 'leibniz-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'extprop-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'extlambda-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'extforall-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'extexists-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'congruence-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'if-then-congruence-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'if-else-congruence-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'iff-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'not-iff-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'if-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'not-if-rule)
	   (equal nb-premises 2))
      (and (eq rule-name 'rewrite-rule)
	   (equal nb-premises 1))
      (and (eq rule-name 'trusted-rule)
	   t)
      (and (eq rule-name 'tcc-rule)
	   t)
      ))

(defmethod proof? ((proof proof))
  t)

(defmethod proof? (expr)
  (declare (ignore expr))
  nil)

(defun proof-list? (proofs)
  (and (listp proofs)
       (every #'(lambda (proof) (proof? proof)) proofs)))

(defun expr-list? (exprs)
  (and (listp exprs)
       (every #'(lambda (expr) (expr? expr)) exprs)))

(defun expr-list-list? (exprs-list)
  (and (listp exprs-list)
       (every #'(lambda (exprs) (expr-list? exprs)) exprs-list)))

(defun sequent-list? (sequents)
  (and (listp sequents)
       (every #'(lambda (sequent) (sequent? sequent)) sequents)))

(defun subst-list? (alist)
  (and (listp alist)
       (every #'(lambda (pair) (and (binding? (car pair))
				    (expr? (cdr pair))))
	      alist)))
