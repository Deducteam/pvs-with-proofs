(defparameter *pvs-with-proofs-path* (environment-variable "PVS_WITH_PROOFS_PATH"))
(defvar *ctxdebug* nil)
(defvar *check-traces* nil)
(defvar *proofdebug* nil)

(defun load-pvs-with-proofs (&optional launch)
  (lf (format nil "~a/compute.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/ctx.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/proofs.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/traces.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/tptp.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/dedukti.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/print.lisp" *pvs-with-proofs-path*))
  ;; Change what is a proofstate
  (lf (format nil "~a/new-defcl.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/new-estructures.lisp" *pvs-with-proofs-path*))
  ;; Adapt its automatically generated methods accordingly
  (write-new-deferred-methods-to-file)
  (lf (format nil "~a/new-pvs-methods.lisp" *pvs-with-proofs-path*))
  ;; Construct proofs
  (lf (format nil "~a/src/substit.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/gensubst.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/makes.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/utils.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/decision-procedure-interface.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/rules.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/eproofcheck.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/proofrules.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/beta-reduce.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/replace.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/equantifiers.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/equalities.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/judgements.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/checker-macros.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/strategies.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/translate-to-yices2.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/set-type.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/assert.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/prover/expand.lisp" *pvs-with-proofs-path*))
  (lf (format nil "~a/src/tcc-gen.lisp" *pvs-with-proofs-path*))
  (unless launch
    (lf (format nil "~a/pvs-with-proofs.lisp" *pvs-with-proofs-path*))))

;; (when (and (typep ex 'name-expr) (eq (id ex) 'n)) (show *current-theory*))

(defparameter *tptp-stream* t)
(defparameter *tptp-count* 0)
(defparameter *tptp* nil)

(defun pvs-with-proofs (theory-name &optional lemma-name (dedukti nil) (tptp nil))
  (when tptp
    (setq *tptp* t))
  (setq *ctxdebug* nil)
  (typecheck-file theory-name t)
  (let* ((decls (all-declarations (get-theory theory-name)))
	 (proved (remove-if-not #'(lambda (d) (and (formula-decl? d)
						   (or (eq (spelling d) 'LEMMA)
						       (eq (spelling d) 'THEOREM))))
				decls)))
    (with-open-file
     (stream (format nil "~A.proof" theory-name) :direction :output :if-exists :supersede)
     (dolist (decl proved)
       (when (or (not lemma-name)
		 (equal (id decl) lemma-name))
	 (let* ((*noninteractive* t)
		(proofstate (prove-decl decl :strategy '(rerun)))
		(sequent (make-instance 'sequent
					:s-forms
					(list
					 (make-instance 's-formula
							:formula
							(closed-definition decl)))))
		(partial-proof (cdr (status proofstate))))
	   (let ((*current-context* (context decl))
		 (*generate-tccs* 'none))
	     (setf (declaration *current-context*) decl)
	     (when *proofdebug* (assert-debug (well-typed-trace partial-proof nil sequent)
					    "PVS-WITH-PROOFS ERROR" nil)))
	   (format stream "~a~%" (id decl))
	   (format stream "~a~%" partial-proof)))))
    (when dedukti
      (with-open-file
       (stream (format nil "~A.dk" theory-name) :direction :output :if-exists :supersede)
       (with-open-file
	(*tptp-stream* (format nil "~A.p" theory-name) :direction :output :if-exists :supersede)
	(print-dk-line stream (make-instance 'dk-prelude :name theory-name))
	(setq *tptp-count* 1)
	(dolist (d decls)
	  (let ((*current-context* (context d)))
	    (setf (declaration *current-context*) d)
	    (print-dk-line stream (mk-dk-context-line d))))
	(dolist (decl proved)
	  (when (or (not lemma-name) (equal (id decl) lemma-name))
	    (let* ((*current-context* (context decl))
		   (*generate-tccs* 'none)
		   (*noninteractive* t)
		   (proofstate (prove-decl decl :strategy '(rerun)))
		   (partial-proof (cdr (status proofstate))))
	      (setf (declaration *current-context*) decl)
	      (output-dk stream decl partial-proof)))))))))

(defun pvs-with-proofs-dir (&optional dribble)
  (let* ((test-paths (directory "*.pvs"))
	 (test-names (sort (mapcar #'pathname-name test-paths) #'string<)))
    (dolist (test-name test-names)
	 (format out "~a~%" test-name)
	 (pvs-with-proofs test-name nil out)
	 (format out "~%~%"))))

